%!TEX encoding = UTF-8 Unicode

\documentclass{article}
%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%
%


\usepackage{xcolor}

% Char literal
\colorlet{Char}{darkgray}

% Numeral literal
\colorlet{Numeral}{Char}

% Keyword
\colorlet{Keyword}{red!50!black}

% Module identifier
\colorlet{ModId}{Char}

% Variable identifier and symbol
\colorlet{VarId}{Char}
\colorlet{VarSym}{VarId}

% Data constructor identifier and symbol
\colorlet{ConId}{VarId}
\colorlet{ConSym}{ConId}

% Type variable identifier
\colorlet{TVarId}{gray}

% Type constructor identifier
\colorlet{TConId}{TVarId}
\colorlet{TConSym}{TConId}

% Type class identifier
\colorlet{TClassId}{TVarId}

% Comment
\colorlet{Comment}{blue!45!black}

\newcommand\Char[1]{\textcolor{Char}{\texttt{#1}}}

% Numeral literal
\newcommand\Numeral[1]{\textcolor{Numeral}{\mathsf{#1}}}

% Keyword
\newcommand\Keyword[1]{\textcolor{Keyword}{\textbf{\textsf{#1}}}}

% Module identifier
\newcommand\ModId[1]{\mathord{\textcolor{ModId}{\mathsf{#1}}}}

% Variable identifier and symbol
\newcommand\VarId[1]{\mathord{\textcolor{VarId}{#1}}}
\let\Varid\VarId
\newcommand\VarSym[1]{\mathbin{\textcolor{VarSym}{#1}}}

% Data constructor identifier and symbol
\newcommand\ConId[1]{\mathord{\textcolor{ConId}{\mathsf{#1}}}}
\let\Conid\ConId
\newcommand\ConSym[1]{\mathbin{\textcolor{ConSym}{\mathsf{#1}}}}

% Type variable identifier
\newcommand\TVarId[1]{\mathord{\textcolor{TVarId}{\mathsf{#1}}}}

% Type constructor identifier
\newcommand\TConId[1]{\mathord{\textcolor{TConId}{\mathsf{#1}}}}
% \newcommand\TConSym[1]{\mathbin{#1}}
\newcommand\TConSym[1]{\mathbin{\textcolor{TConSym}{\mathsf{#1}}}}

% Type class identifier
\newcommand\TClassId[1]{\mathord{\textcolor{TClassId}{\textit{\textsf{#1}}}}}

% Comment
\newcommand\Comment[1]{\textcolor{Comment}{\textit{\textsf{#1}}}}

% Package identifier (used in text, not code/math environment)
\newcommand\PkgId[1]{\textcolor{Char}{\texttt{#1}}}




% Comments: one-line, nested, pragmas



\DeclareMathAlphabet{\mathkw}{OT1}{cmss}{bx}{n}

\newcommand{\FN}{\mathsf}
\newcommand{\comment}[1]{\marginpar{#1}}
\newcommand{\ignore}[1]{}



















\usepackage{homework,stmaryrd,wasysym,url,upgreek,subfigure}
\usepackage[margin=1cm]{caption}
\usepackage{xytree}
\usepackage{listings}

\definecolor{gray}{rgb}{0.4,0.4,0.4}

\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  showstringspaces=false,
  commentstyle=\color{gray}\upshape
}

\lstdefinelanguage{XML}
{
  morestring=[b]",
  morestring=[s]{>}{<},
  morecomment=[s]{<?}{?>},
  stringstyle=\color{gray},
  identifierstyle=\color{black},
  keywordstyle=\color{black},
  morekeywords={xmlns,version,type}% list your attributes here
}


\begin{document}
\setmainfont{Times New Roman}

\author{Jonathan Sterling}

\title{A Survey of Phrase Projectivity in Antigone}
\date{April 2013}
\maketitle



\section{Dependency Trees and Their Projectivity}

A dependency tree encodes the head-dependent relation for a string of words,
where arcs are drawn from heads to their dependents. We consider a phrase
\emph{projective} when these arcs do not cross each other, and
\emph{discontinuous} to the extent that any of the arcs intersect.
Figure~\ref{fig:dependency-trees} illustrates the various kinds of projectivity
violations that may occur.

\begin{figure}[h!]
\centering
\subfigure[``Full of plentiful supplies'' (Xenophon, \emph{Anabasis} 3.5.1) is fully projective.]{
  \xytext{
    \xybarnode{μεστῇ}\xybarconnect[6]{2}&
    \xybarnode{πολλῶν}&
    \xybarnode{ἀγαθῶν}\xybarconnect[3]{-1}
  }
}
\hspace{6pt}
\subfigure[``Full of many good things'' (Plato, \emph{Laws} 906a) has one
projectivity violation.]{
  \xytext{
    \xybarnode{πολλῶν}&
    \xybarnode{μεστὸν}\xybarconnect[6]{1}&
    \xybarnode{ἀγαθῶν}\xybarconnect[3]{-2}
  }
}
\subfigure[``And he stood over the rooftops, gaped in a circle with murderous
spears around the seven-gated mouth, and left'' (Sophocles, \emph{Antigone}
117--120) has five projectivity violations (note that multiple arcs may
intersect at a point).]{
  \xytext{
    \xybarnode{στὰς}\xybarconnect[6]{2} &
    \xybarnode{δ'} &
    \xybarnode{ὑπὲρ}\xybarconnect[3]{1} &
    \xybarnode{μελάθρων} &
    \xybarnode{φονώσαισιν}\xybarconnect[3]{3} &
    \xybarnode{ἀμφιχανὼν}
      \xybarconnect[6]{1}
      \xybarconnect[6]{2}
      \xybarconnect[6]{4}&
    \xybarnode{κύκλῳ} &
    \xybarnode{λόγχαις} &
    \xybarnode{ἐπτάπυλον} &
    \xybarnode{στόμα}\xybarconnect[3]{-1} &
    \xybarnode{ἔβα}
      \xybarconnect[9]{-10}
      \xybarconnect[9]{-9}
      \xybarconnect[9]{-5}
  }
}

\caption{A dependency path wrapping around itself is a projectivity violation,
as in (b); interlacing adjacent phrases also violate projectivity, as in
(c). Examples (a--b) drawn from Devine~\&~Stephens.}
\label{fig:dependency-trees}
\end{figure}

\noindent
In this paper, we use a concrete metric of projectivity $\omega$, given by the following
ratio:
\[
    \omega = \frac{\text{number of violations}}{\text{number of arcs}}
\]
Section~\ref{sec:algorithm} deals with the development of an algorithm to
compute this quantity for a particular dependency tree.

\section{Algorithm \& Data Representation}
\label{sec:algorithm}

Dependency trees are a recursive data structure
with a head node, which may have any number of arcs drawn to further trees (this
is called a \emph{rose tree}). We represent them as a Haskell data-type as
follows:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathkw{data}\;\mathsf{Tree}\;\VarSym{\alpha}\mathrel{=}\VarSym{\alpha}\curvearrowright[\mskip1.5mu \mathsf{Tree}\;\VarSym{\alpha}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
This can be read as ``For all types \ensuremath{\VarSym{\alpha}}, a \ensuremath{\mathsf{Tree}} of \ensuremath{\VarSym{\alpha}} is constructed from a
\emph{label} of type \ensuremath{\VarSym{\alpha}} and a \emph{subforest} of \ensuremath{\mathsf{Tree}}s of \ensuremath{\VarSym{\alpha}},'' where brackets are a notation
for lists.

Given a tree, we can extract its root label or its subforest by pattern matching
on its structure as follows:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\FN{getLabel}\ConSym{::}\mathsf{Tree}\;\VarSym{\alpha}\to \VarSym{\alpha}{}\<[E]%
\\
\>[3]{}\FN{getLabel}\;(\Varid{l}\curvearrowright\anonymous )\mathrel{=}\Varid{l}{}\<[E]%
\\
\>[3]{}\FN{getForest}\ConSym{::}\mathsf{Tree}\;\VarSym{\alpha}\to [\mskip1.5mu \mathsf{Tree}\;\VarSym{\alpha}\mskip1.5mu]{}\<[E]%
\\
\>[3]{}\FN{getForest}\;(\anonymous \curvearrowright\Varid{ts})\mathrel{=}\Varid{ts}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\subsection{From Edges to Trees}

A sentence from the Perseus treebank is in the form of a list of words that are
indexed by their linear position, and cross-referenced by the linear position of
their dominating head. We shall consider each index to be a \emph{vertex}, and
each pair of vertices to be an \ensuremath{\mathsf{Edge}}, which we shall write as follows:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathkw{data}\;\mathsf{Edge}\;\VarSym{\alpha}\mathrel{=}\VarSym{\alpha}\leftrightarrow\VarSym{\alpha}\;\mathkw{deriving}\;\mathsf{Eq}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\ignore{
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathkw{deriving}\;\mathkw{instance}\;\mathsf{Show}\;\VarSym{\alpha}\Rightarrow \mathsf{Show}\;(\mathsf{Edge}\;\VarSym{\alpha}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
}
%
An \ensuremath{\mathsf{Edge}\;\VarSym{\alpha}} is given by two vertices of type \ensuremath{\VarSym{\alpha}}; the \ensuremath{\mathkw{deriving}\;\mathsf{Eq}} statement
generates the code that is necessary to determine whether or not two \ensuremath{\mathsf{Edge}}s are
equal using the \ensuremath{(\equiv )} operator. In order to perform our analysis, we should wish
to transform the raw list of edges into a tree structure. The basic procedure is
as follows:

First, we try to find the root vertex of the tree. This will be a vertex that is
given as the head of one of the words, but does not itself appear in the
sentence:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\FN{rootVertex}\ConSym{::}\mathsf{Eq}\;\VarSym{\alpha}\Rightarrow [\mskip1.5mu \mathsf{Edge}\;\VarSym{\alpha}\mskip1.5mu]\to \mathsf{Maybe}\;\VarSym{\alpha}{}\<[E]%
\\
\>[3]{}\FN{rootVertex}\;\Varid{es}\mathrel{=}\FN{find}\;(\notin \FN{deps})\;\FN{heads}\;\mathkw{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\FN{heads}{}\<[12]%
\>[12]{}\mathrel{=}\llbracket\;(\lambda (\Varid{x}\leftrightarrow\Varid{y})\to \Varid{x})\;\Varid{es}\;\rrbracket{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\FN{deps}{}\<[12]%
\>[12]{}\mathrel{=}\llbracket\;(\lambda (\Varid{x}\leftrightarrow\Varid{y})\to \Varid{y})\;\Varid{es}\;\rrbracket{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
If the data that we are working with are not well-formed, there is a chance that
we will not find a root vertex; that is why the type is given as \ensuremath{\mathsf{Maybe}}.

Then, given a root vertex, we look to find all the edges that
it touches, and try to build the subtrees that are connected with those edges.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\FN{onEdge}\ConSym{::}\mathsf{Eq}\;\VarSym{\alpha}\Rightarrow \VarSym{\alpha}\to \mathsf{Edge}\;\VarSym{\alpha}\to \mathbb{B}{}\<[E]%
\\
\>[3]{}\FN{onEdge}\;\Varid{i}\;(\Varid{x}\leftrightarrow\Varid{y})\mathrel{=}\Varid{x}\equiv \Varid{i}\mathrel{\vee}\Varid{y}\equiv \Varid{i}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\FN{oppositeVertex}\ConSym{::}\mathsf{Eq}\;\VarSym{\alpha}\Rightarrow \VarSym{\alpha}\to \mathsf{Edge}\;\VarSym{\alpha}\to \VarSym{\alpha}{}\<[E]%
\\
\>[3]{}\FN{oppositeVertex}\;\Varid{i}\;(\Varid{x}\leftrightarrow\Varid{y}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mid \Varid{x}\equiv \Varid{i}{}\<[18]%
\>[18]{}\mathrel{=}\Varid{y}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mid otherwise{}\<[18]%
\>[18]{}\mathrel{=}\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
This is done recursively until the list of edges is exhausted and we have a
complete tree structure:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\FN{treeFromEdges}\ConSym{::}\mathsf{Ord}\;\VarSym{\alpha}\Rightarrow [\mskip1.5mu \mathsf{Edge}\;\VarSym{\alpha}\mskip1.5mu]\to \mathsf{Maybe}\;(\mathsf{Tree}\;\VarSym{\alpha}){}\<[E]%
\\
\>[3]{}\FN{treeFromEdges}\;\Varid{es}\mathrel{=}\llbracket\;(\FN{buildWithRoot}\;\Varid{es})\;(\FN{rootVertex}\;\Varid{es})\;\rrbracket\;\mathkw{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\FN{buildWithRoot}\;\Varid{es}\;\Varid{root}\mathrel{=}\Varid{root}\curvearrowright\FN{sortedChildren}\;\mathkw{where}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\FN{roots}{}\<[24]%
\>[24]{}\mathrel{=}\llbracket\;(\FN{oppositeVertex}\;\Varid{root})\;\FN{localVertices}\;\rrbracket{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\FN{children}{}\<[24]%
\>[24]{}\mathrel{=}\llbracket\;(\FN{buildWithRoot}\;\FN{foreignVertices})\;\FN{roots}\;\rrbracket{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\FN{localVertices}{}\<[24]%
\>[24]{}\mathrel{=}\FN{filter}\;(\FN{onEdge}\;\Varid{root})\;\Varid{es}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\FN{foreignVertices}{}\<[24]%
\>[24]{}\mathrel{=}\FN{filter}\;(\neg \circ\FN{onEdge}\;\Varid{root})\;\Varid{es}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\FN{sortedChildren}{}\<[24]%
\>[24]{}\mathrel{=}\FN{sortBy}\;(\FN{compare}\mathbin{`\FN{on}`}\FN{getLabel})\;\FN{children}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Counting Violations: Computing \ensuremath{\FN{\omega}}}
Violations are given as an integer tally:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathkw{type}\;\mathsf{Violations}\mathrel{=}\mathbb{Z}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The basic procedure for counting projectivity violations is as follows: flatten
down the tree into a list of edges cross-referenced by their vertical position
in the tree; then traverse the list and see how many times these edges intersect
each other.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathkw{type}\;\mathsf{Level}\mathrel{=}\mathbb{Z}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The vertical position of a node in a tree is represented as its \ensuremath{\mathsf{Level}},
counting backwards from the total depth of the tree. That is, the deepest node
in the tree is at level \ensuremath{\Numeral{0}}, and the highest node in the tree is at level \ensuremath{\Varid{n}},
where \ensuremath{\Varid{n}} is the tree's depth.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\FN{levels}\ConSym{::}\mathsf{Tree}\;\VarSym{\alpha}\to [\mskip1.5mu [\mskip1.5mu \VarSym{\alpha}\mskip1.5mu]\mskip1.5mu]{}\<[E]%
\\
\>[3]{}\FN{levels}\;\Varid{t}\mathrel{=}\FN{fmap}\;(\FN{fmap}\;\FN{getLabel})\mathbin{\$}{}\<[E]%
\\
\>[3]{}\hsindent{12}{}\<[15]%
\>[15]{}\FN{takeWhile}\;(\neg \circ\FN{null})\mathbin{\$}{}\<[E]%
\\
\>[3]{}\hsindent{12}{}\<[15]%
\>[15]{}\FN{iterate}\;(\bind \FN{getForest})\;[\mskip1.5mu \Varid{t}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\FN{depth}\ConSym{::}\mathsf{Tree}\;\VarSym{\alpha}\to \mathbb{Z}{}\<[E]%
\\
\>[3]{}\FN{depth}\mathrel{=}\FN{length}\circ\FN{levels}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
We can now annotate each node in a tree with what level it is at:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\FN{annotateLevels}\ConSym{::}\mathsf{Tree}\;\VarSym{\alpha}\to \mathsf{Tree}\;(\mathsf{Level},\VarSym{\alpha}){}\<[E]%
\\
\>[3]{}\FN{annotateLevels}\;\Varid{tree}\mathrel{=}\FN{aux}\;(\FN{depth}\;\Varid{tree})\;\Varid{tree}\;\mathkw{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\FN{aux}\;\Varid{l}\;(\Varid{x}\curvearrowright\Varid{ts})\mathrel{=}(\Varid{l},\Varid{x})\curvearrowright\llbracket\;(\FN{aux}\;(\Varid{l}\VarSym{-}\Numeral{1}))\;\Varid{ts}\;\rrbracket{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Then, we fold up the tree into a list of edges and levels:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\FN{allEdges}\ConSym{::}\mathsf{Ord}\;\VarSym{\alpha}\Rightarrow \mathsf{Tree}\;\VarSym{\alpha}\to [\mskip1.5mu (\mathsf{Level},\mathsf{Edge}\;\VarSym{\alpha})\mskip1.5mu]{}\<[E]%
\\
\>[3]{}\FN{allEdges}\;\Varid{tree}\mathrel{=}\FN{aux}\;(\FN{annotateLevels}\;\Varid{tree})\;\mathkw{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\FN{aux}\;((\anonymous ,\Varid{x})\curvearrowright\Varid{ts})\mathrel{=}\Varid{ts}\bind \FN{go}\;\mathkw{where}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\FN{go}\;\Varid{t}\mathord{@}((\Varid{l},\Varid{y})\curvearrowright\anonymous )\mathrel{=}(\Varid{l},\FN{edgeWithRange}\;[\mskip1.5mu \Varid{x},\Varid{y}\mskip1.5mu])\mathbin{:}\FN{aux}\;\Varid{t}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\FN{edgeWithRange}\ConSym{::}(\mathsf{Ord}\;\VarSym{\alpha})\Rightarrow [\mskip1.5mu \VarSym{\alpha}\mskip1.5mu]\to \mathsf{Edge}\;\VarSym{\alpha}{}\<[E]%
\\
\>[3]{}\FN{edgeWithRange}\;\Varid{xs}\mathrel{=}\FN{minimum}\;\Varid{xs}\leftrightarrow\FN{maximum}\;\Varid{xs}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
A handy way to think of edges annotated by levels is as a representation of the
arc itself, where the vertices of the edge are the endpoints, and the level is the
height of the arc.

If one end of an arc is between the ends of another, then there is a single
intersection. If one arc is higher than another and the latter is in between the
endpoints of the former, there is no violation; but if they are at the same
level, or if the latter is higher than the former, there is a double
intersection. Otherwise, there is no intersection.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{48}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\FN{checkEdges}\ConSym{::}\mathsf{Ord}\;\VarSym{\alpha}\Rightarrow (\mathsf{Level},\mathsf{Edge}\;\VarSym{\alpha})\to (\mathsf{Level},\mathsf{Edge}\;\VarSym{\alpha})\to \mathsf{Violations}{}\<[E]%
\\
\>[3]{}\FN{checkEdges}\;(\Varid{l},\Varid{xy}\mathord{@}(\Varid{x}\leftrightarrow\Varid{y}))\;(\Varid{l'},\Varid{uv}\mathord{@}(\Varid{u}\leftrightarrow\Varid{v})){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mid \Varid{y}\in_E\Varid{uv}\mathrel{\wedge}\Varid{u}\in_E\Varid{xy}{}\<[48]%
\>[48]{}\mathrel{=}\Numeral{1}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mid \Varid{x}\in_E\Varid{uv}\mathrel{\wedge}\Varid{v}\in_E\Varid{xy}{}\<[48]%
\>[48]{}\mathrel{=}\Numeral{1}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mid \Varid{x}\in_E\Varid{uv}\mathrel{\wedge}\Varid{y}\in_E\Varid{uv}\mathrel{\wedge}\Varid{l}\geq \Varid{l'}{}\<[48]%
\>[48]{}\mathrel{=}\Numeral{2}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mid \Varid{u}\in_E\Varid{xy}\mathrel{\wedge}\Varid{v}\in_E\Varid{xy}\mathrel{\wedge}\Varid{l}\leq \Varid{l'}{}\<[48]%
\>[48]{}\mathrel{=}\Numeral{2}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mid otherwise{}\<[48]%
\>[48]{}\mathrel{=}\Numeral{0}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
We determine whether a vertex is in the bounds of an edge using \ensuremath{\cdot \in_E\cdot }.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}c<{\hspost}@{}}%
\column{24E}{@{}l@{}}%
\column{28}{@{}>{\hspre}l<{\hspost}@{}}%
\column{42}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\cdot \in_E\cdot \ConSym{::}\mathsf{Ord}\;\VarSym{\alpha}\Rightarrow \VarSym{\alpha}\to \mathsf{Edge}\;\VarSym{\alpha}\to \mathbb{B}{}\<[E]%
\\
\>[3]{}\Varid{z}\in_E\Varid{x}\leftrightarrow\Varid{y}{}\<[24]%
\>[24]{}\mathrel{=}{}\<[24E]%
\>[28]{}\Varid{z}\VarSym{>}\FN{minimum}\;{}\<[42]%
\>[42]{}[\mskip1.5mu \Varid{x},\Varid{y}\mskip1.5mu]{}\<[E]%
\\
\>[24]{}\mathrel{\wedge}{}\<[24E]%
\>[28]{}\Varid{z}\VarSym{<}\FN{maximum}\;{}\<[42]%
\>[42]{}[\mskip1.5mu \Varid{x},\Varid{y}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
We can now use what we've built to count the intersections that occur in a
collection of edges. This is done by adding up the result of \ensuremath{\FN{checkEdges}} of the
combination of each edge with the subset of edges which are at or below its
level:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\FN{edgeViolations}\ConSym{::}\mathsf{Ord}\;\VarSym{\alpha}\Rightarrow [\mskip1.5mu (\mathsf{Level},\mathsf{Edge}\;\VarSym{\alpha})\mskip1.5mu]\to \mathsf{Violations}{}\<[E]%
\\
\>[3]{}\FN{edgeViolations}\;\Varid{xs}\mathrel{=}\FN{sum}\;\llbracket\;\FN{violationsWith}\;\Varid{xs}\;\rrbracket\;\mathkw{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\FN{rangesBelow}\;(\Varid{l},\anonymous ){}\<[25]%
\>[25]{}\mathrel{=}\FN{filter}\;(\lambda (\Varid{l'},\anonymous )\to \Varid{l'}\leq \Varid{l})\;\Varid{xs}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\FN{violationsWith}\;\Varid{x}{}\<[25]%
\>[25]{}\mathrel{=}\FN{sum}\;\llbracket\;(\FN{checkEdges}\;\Varid{x})\;(\FN{rangesBelow}\;\Varid{x})\;\rrbracket{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Finally, \ensuremath{\FN{\omega}} is computed for a tree as follows:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\FN{\omega}\ConSym{::}\mathsf{Ord}\;\VarSym{\alpha}\Rightarrow \mathsf{Tree}\;\VarSym{\alpha}\to \mathbb{Q}{}\<[E]%
\\
\>[3]{}\FN{\omega}\;\Varid{tree}\mathrel{=}\dfrac{\FN{violationsCount}}{\FN{totalArcsCount}}\;\mathkw{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\FN{edges}{}\<[22]%
\>[22]{}\mathrel{=}\FN{allEdges}\;\Varid{tree}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\FN{violationsCount}{}\<[22]%
\>[22]{}\mathrel{=}\FN{fromIntegral}\;(\FN{edgeViolations}\;\FN{edges}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\FN{totalArcsCount}{}\<[22]%
\>[22]{}\mathrel{=}\FN{length}\;\FN{edges}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\newpage
\section{Parsing the Perseus Treebank}

The Persues treebank is a collection of XML files, which have data in the
following (simplified) scheme:

\lstset{
  language=XML,
  escapeinside=**
}

\begin{lstlisting}
    <sentence id="2900759">
      <word id="1" form="*\color{gray}\textrm{χρὴ}*" lemma="*\color{gray}\textrm{χρή}*" head="0" />
      <word id="2" form="*\color{gray}\textrm{δὲ}*" lemma="*\color{gray}\textrm{δέ}*" head="1" />
      ...
    </sentence>

    <sentence id="2900760">
      <word id="1" form="*\color{gray}\textrm{μεγάλοι}*" lemma="*\color{gray}\textrm{μέγας}*" head="3" />
      <word id="2" form="*\color{gray}\textrm{δὲ}*" lemma="*\color{gray}\textrm{δέ}*" head="12" />
      ...
    </sentence>
\end{lstlisting}

We can express the general shape of such a document as follows:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathkw{newtype}\;\mathsf{XML}{}\<[21]%
\>[21]{}\mathrel{=}\mathsf{XML}\;[\mskip1.5mu \mathsf{Content}\mskip1.5mu]{}\<[E]%
\\
\>[3]{}\mathkw{newtype}\;\mathsf{Word}{}\<[21]%
\>[21]{}\mathrel{=}\mathsf{Word}\;\mathsf{Element}{}\<[E]%
\\
\>[3]{}\mathkw{newtype}\;\mathsf{Sentence}{}\<[21]%
\>[21]{}\mathrel{=}\mathsf{Sentence}\;\mathsf{Element}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
To convert XML into trees, we must first extract the sentences from the file, and then we
convert those into trees.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\FN{sentencesFromXML}\ConSym{::}\mathsf{XML}\to [\mskip1.5mu \mathsf{Sentence}\mskip1.5mu]{}\<[E]%
\\
\>[3]{}\FN{sentencesFromXML}\;(\mathsf{XML}\;\Varid{xml})\mathrel{=}\mathkw{do}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{elems}{}\<[16]%
\>[16]{}\leftarrow \FN{onlyElems}\;\Varid{xml}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\llbracket\;\mathsf{Sentence}\;(\FN{findElements}\;(\FN{simpleName}\;\Char{\char34 sentence\char34})\;\Varid{elems})\;\rrbracket{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
To build a tree from a sentence, first we get all of the words from that
sentence and convert them into edges.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\FN{wordsFromSentence}\ConSym{::}\mathsf{Sentence}\to [\mskip1.5mu \mathsf{Word}\mskip1.5mu]{}\<[E]%
\\
\>[3]{}\FN{wordsFromSentence}\;(\mathsf{Sentence}\;\Varid{s})\mathrel{=}\llbracket\;\mathsf{Word}\;(\FN{findChildren}\;(\FN{simpleName}\;\Char{\char34 word\char34})\;\Varid{s})\;\rrbracket{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Edges are the content of the \lstinline{head} attribute paired with that of the
\lstinline{id} attribute.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\FN{edgeFromWord}\ConSym{::}\mathsf{Word}\to \mathsf{Maybe}\;(\mathsf{Edge}\;\mathbb{Z}){}\<[E]%
\\
\>[3]{}\FN{edgeFromWord}\;(\mathsf{Word}\;\Varid{w})\mathrel{=}\llbracket\;(\FN{readAttr}\;\Char{\char34 head\char34}\;\Varid{w})\;\leftrightarrow\;(\FN{readAttr}\;\Char{\char34 id\char34}\;\Varid{w})\;\rrbracket{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Thence, we can build a tree from a sentence.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\FN{treeFromSentence}\ConSym{::}\mathsf{Sentence}\to \mathsf{Maybe}\;(\mathsf{Tree}\;\mathbb{Z}){}\<[E]%
\\
\>[3]{}\FN{treeFromSentence}\mathrel{=}\FN{treeFromEdges}\circ\FN{edgesFromSentence}\;\mathkw{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\FN{edgesFromSentence}\ConSym{::}\mathsf{Sentence}\to [\mskip1.5mu \mathsf{Edge}\;\mathbb{Z}\mskip1.5mu]{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\FN{edgesFromSentence}\;\Varid{s}\mathrel{=}\FN{catMaybes}\;\llbracket\;\FN{edgeFromWord}\;(\FN{wordsFromSentence}\;\Varid{s})\;\rrbracket\;\mathkw{where}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
By putting the pieces together, we also derive a function to read all the trees
from an XML document:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\FN{treesFromXML}\ConSym{::}\mathsf{XML}\to [\mskip1.5mu \mathsf{Tree}\;\mathbb{Z}\mskip1.5mu]{}\<[E]%
\\
\>[3]{}\FN{treesFromXML}\;\Varid{xml}\mathrel{=}\FN{catMaybes}\;\llbracket\;\FN{treeFromSentence}\;(\FN{sentencesFromXML}\;\Varid{xml})\;\rrbracket{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Finally, we must read the file as a string, parse it as XML, and then convert
that XML into a series of trees.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\FN{treesFromFile}\ConSym{::}\mathsf{FilePath}\to \mathsf{IO}\;[\mskip1.5mu \mathsf{Tree}\;\mathbb{Z}\mskip1.5mu]{}\<[E]%
\\
\>[3]{}\FN{treesFromFile}\;\Varid{path}\mathrel{=}\llbracket\;(\FN{treesFromXML}\circ\mathsf{XML}\circ\FN{parseXML})\;(\FN{readFile}\;\Varid{path})\;\rrbracket{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\section{Analysis of Data}

We compute the average \ensuremath{\FN{\omega}} of the trees contained in a file as follows:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\FN{analyzeFile}\ConSym{::}\mathsf{FilePath}\to \mathsf{IO}\;\mathbb{Q}{}\<[E]%
\\
\>[3]{}\FN{analyzeFile}\;\Varid{path}\mathrel{=}\mathkw{do}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{trees}\leftarrow \FN{treesFromFile}\;\Varid{path}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\FN{return}\;(\FN{average}\;\llbracket\;\FN{\omega}\;\Varid{trees}\;\rrbracket){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\section*{Appendix: Auxiliary Functions}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\FN{simpleName}\ConSym{::}\mathsf{String}\to \mathsf{QName}{}\<[E]%
\\
\>[3]{}\FN{simpleName}\;\Varid{s}\mathrel{=}\mathsf{QName}\;\Varid{s}\;\mathsf{Nothing}\;\mathsf{Nothing}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\FN{readAttr}\ConSym{::}\mathsf{Read}\;\VarSym{\alpha}\Rightarrow \mathsf{String}\to \mathsf{Element}\to \mathsf{Maybe}\;\VarSym{\alpha}{}\<[E]%
\\
\>[3]{}\FN{readAttr}\;\Varid{n}\mathrel{=}\FN{fmap}\;\FN{read}\circ\FN{findAttr}\;(\FN{simpleName}\;\Varid{n}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\FN{average}\ConSym{::}\mathsf{Fractional}\;\Varid{n}\Rightarrow [\mskip1.5mu \Varid{n}\mskip1.5mu]\to \Varid{n}{}\<[E]%
\\
\>[3]{}\FN{average}\;\Varid{xs}\mathrel{=}\dfrac{\FN{sum}\;\Varid{xs}}{\FN{length}\;\Varid{xs}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\ignore{
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\llbracket\;\cdot \;\cdot \;\cdot \;\rrbracket\mathrel{=}\llbracket\;\cdot \;\cdot \;\cdot \;\rrbracket{}\<[E]%
\\
\>[3]{}\dfrac{\cdot }{\cdot }\mathrel{=}(\mathbin{\%}){}\<[E]%
\\
\>[3]{}\dfrac{\cdot }{\cdot }\mathrel{=}(\mathbin{/}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
}

\end{document}


